// Cyberhost UK Malware Hosts Sync Function
// Downloads malware hosts list (0.0.0.0 format) and extracts domains from second column
import { corsHeaders } from '../_shared/cors.ts';
import { supabaseQuery, supabaseUpsert } from '../_shared/supabase-rest.ts';
import { logNetworkCall, updateNetworkLog } from '../_shared/network-logger.ts';

const CYBERHOST_HOSTS_URL = 'https://lists.cyberhost.uk/malware_hosts.txt';
const BATCH_SIZE = 5000;

/**
 * Parse hosts file format and extract domain from second column
 * Format: "0.0.0.0 domain.com"
 */
function parseCyberhostHostsDomain(line: string): string | null {
  // Step 1: Normalize
  const cleaned = line
    .replace(/\r/g, '')
    .trim();
  
  // Step 2: Skip comments and empty lines
  if (!cleaned || cleaned.startsWith('#')) {
    return null;
  }
  
  // Step 3: Split by whitespace
  const parts = cleaned.split(/\s+/);
  
  // Step 4: Expect format "0.0.0.0 domain" or "127.0.0.1 domain"
  if (parts.length < 2) {
    return null;
  }
  
  // Step 5: Extract domain (second column)
  const domain = parts[1].toLowerCase();
  
  // Step 6: Validate FQDN format
  const fqdnRegex = /^([a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?\.)+[a-z]{2,}$/;
  if (!fqdnRegex.test(domain)) {
    return null;
  }
  
  // Step 7: Filter invalid patterns
  const domainParts = domain.split('.');
  if (
    domain === 'localhost' ||
    domainParts.length < 2 ||
    domain.includes('_')
  ) {
    return null;
  }
  
  return domain;
}

/**
 * Batch upsert domains into raw_indicators table
 */
async function upsertDomainBatch(
  url: string,
  serviceKey: string,
  domains: string[],
  source: string
): Promise<void> {
  const records = domains.map(domain => ({
    indicator: domain,
    kind: 'domain',
    source: source,
    first_seen: new Date().toISOString(),
    last_seen: new Date().toISOString()
  }));

  await supabaseUpsert(
    url,
    serviceKey,
    'raw_indicators',
    records,
    ['indicator', 'source']
  );
}

Deno.serve(async (req) => {
  // Handle CORS preflight
  if (req.method === 'OPTIONS') {
    return new Response(null, { headers: corsHeaders });
  }

  const startTime = Date.now();
  let networkLogId: string | null = null;

  try {
    // Validate cron secret
    const cronSecret = req.headers.get('x-cron-secret');
    const expectedSecret = Deno.env.get('CRON_SECRET');
    
    if (cronSecret !== expectedSecret) {
      console.error('❌ Invalid or missing cron secret');
      return new Response(
        JSON.stringify({ error: 'Unauthorized' }),
        { status: 401, headers: { ...corsHeaders, 'Content-Type': 'application/json' } }
      );
    }

    const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
    const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;

    console.log('🚀 Starting Cyberhost Malware Hosts sync...');

    // Log network call start
    networkLogId = await logNetworkCall(supabaseUrl, serviceKey, {
      call_type: 'ingest',
      target_url: CYBERHOST_HOSTS_URL,
      target_name: 'Cyberhost UK Malware Hosts',
      method: 'GET',
      edge_function_name: 'cyberhost-malware-hosts-sync'
    });

    // Fetch the hosts file
    console.log('📥 Fetching hosts file from Cyberhost UK...');
    const fetchStart = Date.now();
    const response = await fetch(CYBERHOST_HOSTS_URL);
    const fetchTime = Date.now() - fetchStart;

    if (!response.ok) {
      throw new Error(`Failed to fetch: ${response.status} ${response.statusText}`);
    }

    const content = await response.text();
    const contentLength = new TextEncoder().encode(content).length;
    console.log(`✅ Downloaded ${(contentLength / 1024).toFixed(2)} KB in ${fetchTime}ms`);

    // Update network log with download stats
    if (networkLogId) {
      await updateNetworkLog(supabaseUrl, serviceKey, networkLogId, {
        status: 'active',
        status_code: response.status,
        response_time_ms: fetchTime,
        bytes_transferred: contentLength
      });
    }

    // Parse domains from hosts file (second column)
    console.log('🔍 Parsing domains from hosts file...');
    const parseStart = Date.now();
    const lines = content.split('\n');
    const domains: string[] = [];
    let validCount = 0;
    let invalidCount = 0;
    let commentCount = 0;

    for (const line of lines) {
      if (!line.trim()) continue;
      
      if (line.trim().startsWith('#')) {
        commentCount++;
        continue;
      }

      const domain = parseCyberhostHostsDomain(line);
      if (domain) {
        domains.push(domain);
        validCount++;
      } else {
        invalidCount++;
      }
    }

    const parseTime = Date.now() - parseStart;
    console.log(`✅ Parsed ${lines.length} lines in ${parseTime}ms`);
    console.log(`   ✓ Valid domains: ${validCount}`);
    console.log(`   ✗ Invalid/skipped: ${invalidCount}`);
    console.log(`   # Comments: ${commentCount}`);

    // Upsert domains in batches
    if (domains.length > 0) {
      console.log(`💾 Upserting ${domains.length} domains in batches of ${BATCH_SIZE}...`);
      const upsertStart = Date.now();
      
      for (let i = 0; i < domains.length; i += BATCH_SIZE) {
        const batch = domains.slice(i, i + BATCH_SIZE);
        const batchNum = Math.floor(i / BATCH_SIZE) + 1;
        const totalBatches = Math.ceil(domains.length / BATCH_SIZE);
        
        console.log(`   📦 Processing batch ${batchNum}/${totalBatches} (${batch.length} domains)`);
        await upsertDomainBatch(supabaseUrl, serviceKey, batch, 'cyberhost_malware_hosts');
      }
      
      const upsertTime = Date.now() - upsertStart;
      console.log(`✅ Upsert completed in ${upsertTime}ms`);
    }

    // Update network log - completed
    if (networkLogId) {
      await updateNetworkLog(supabaseUrl, serviceKey, networkLogId, {
        status: 'completed',
        items_processed: validCount
      });
    }

    // Update ingest_sources table
    const totalTime = Date.now() - startTime;
    await supabaseQuery(
      supabaseUrl,
      serviceKey,
      'ingest_sources',
      'PATCH',
      {
        last_run: new Date().toISOString(),
        last_success: new Date().toISOString(),
        last_attempt: new Date().toISOString(),
        indicators_count: validCount,
        last_error: null
      },
      `?name=eq.Cyberhost UK Malware Hosts`
    );

    const result = {
      success: true,
      source: 'cyberhost_malware_hosts',
      url: CYBERHOST_HOSTS_URL,
      stats: {
        total_lines: lines.length,
        valid_domains: validCount,
        invalid_skipped: invalidCount,
        comments: commentCount,
        batches_processed: Math.ceil(domains.length / BATCH_SIZE)
      },
      timing: {
        fetch_ms: fetchTime,
        parse_ms: parseTime,
        total_ms: totalTime
      }
    };

    console.log('🎉 Cyberhost Malware Hosts sync completed successfully');
    console.log(JSON.stringify(result, null, 2));

    return new Response(
      JSON.stringify(result),
      { 
        status: 200,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );

  } catch (error) {
    const totalTime = Date.now() - startTime;
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    console.error('❌ Cyberhost Malware Hosts sync failed:', errorMessage);

    // Update network log - failed
    if (networkLogId) {
      const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
      const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
      
      await updateNetworkLog(supabaseUrl, serviceKey, networkLogId, {
        status: 'failed',
        error_message: errorMessage
      });
    }

    // Update ingest_sources with error
    try {
      const supabaseUrl = Deno.env.get('SUPABASE_URL')!;
      const serviceKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!;
      
      await supabaseQuery(
        supabaseUrl,
        serviceKey,
        'ingest_sources',
        'PATCH',
        {
          last_run: new Date().toISOString(),
          last_attempt: new Date().toISOString(),
          last_error: errorMessage
        },
        `?name=eq.Cyberhost UK Malware Hosts`
      );
    } catch (updateError) {
      console.error('Failed to update ingest_sources:', updateError);
    }

    return new Response(
      JSON.stringify({
        success: false,
        error: errorMessage,
        timing: { total_ms: totalTime }
      }),
      { 
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' }
      }
    );
  }
});
